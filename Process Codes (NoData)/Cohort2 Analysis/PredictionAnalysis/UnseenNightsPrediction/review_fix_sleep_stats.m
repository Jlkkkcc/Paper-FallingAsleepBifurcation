
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Author: Anastasia Ilina

% Predicting the point of transition from wakefulness to sleep based on 
% a bifurcation model fitted to the a selected number of nights from a
% participant
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Fix directories and initialise some variables 
epoch_dur = 0.5;

cd '/Users/ai421/Dropbox (Personal)/ISN work/Work on new dataset/Critical Point Prediction Review'
addpath '/Users/ai421/Dropbox (Personal)/ISN work/Work on new dataset/Critical Point Prediction Review'
addpath '/Users/ai421/Dropbox (Personal)/ISN work/Work on new dataset/Mean S-variable for prediction/Functions'
%addpath '/Users/ai421/Dropbox (Personal)/ISN work/Work on new dataset/Critical Point Prediction'

smoothingMethod = 'retrospective_median';
smoothingWindow = 20;
smoothingOrder = 4;

%% Preprocess the predicted S-variable results table 
num_nights_for_modelling = 1;
saveDir = '/Users/ai421/Dropbox (Personal)/ISN work/Work on new dataset/Critical Point Prediction Review/';

saveDirAdjustedBifurcation = [saveDir, 'Prediction/', num2str(num_nights_for_modelling), '_Nights_for_Modelling/'];
if ~exist(saveDirAdjustedBifurcation, 'dir')
   mkdir(saveDirAdjustedBifurcation);
end
cd(saveDirAdjustedBifurcation)
% 
% % Load the S-variable prediction results generated by all_participants_mean_script.m
% load FinalMissingDataFixedReviewedSummaryTable.mat
% 
% % Create a logical index for rows where Number_of_Nights_Used equals the
% % number of nights for modelling
% rowsWithOneNight = predictionSummaryTable.Number_of_Nights_Used == num_nights_for_modelling;
% 
% % Use the logical index to select only the rows with Number_of_Nights_Used equal to 1
% newTable = predictionSummaryTable(rowsWithOneNight, :);
% newTable.Nights_for_Modelling = cellfun(@num2str, newTable.Nights_for_Modelling);
% %newTable.Nights_for_Modelling = cellfun(@(x) x, newTable.Nights_for_Modelling);
% 
% % Use the unique function to find and keep only unique rows based on Patient_ID and Nights_for_Modelling
% [~, uniqueIndices] = unique(newTable(:, {'Patient_ID', 'Nights_for_Modelling'}), 'rows');
% 
% % Create a table with only the unique rows
% uniqueTable = newTable(uniqueIndices, :);

%% Initialise storage variables

earliestTimePoints = [];
latestTimePoints = [];
meanTimePoints = [];
allTimePoints = [];
allFalseAlarmRates = [];

for row_idx = 1:height(uniqueTable)

    if uniqueTable.Updated_SVariableCriticalZone(row_idx) == 0
        %sempty(uniqueTable.Updated_R_square(row_idx)) || isnan(uniqueTable.Updated_R_square(row_idx))
    
    %% Adjust the bifurcation fittings to have proper critical points

    uncut_xx_smoothed = uniqueTable.Mean_S_Variable{row_idx};
    uncut_xx_smoothed = uncut_xx_smoothed(1:length(uncut_xx_smoothed) - 9);
    %uncut_tvec = linspace(-30, 10, length(uncut_xx_smoothed));
    uncut_tvec =  (-30*60 + 6):3:10*60;
    uncut_tvec = uncut_tvec / 60;

    if isnan(uncut_xx_smoothed(1))
        % Find the index of the first non-NaN value
        firstNonNaNIndex = find(~isnan(uncut_xx_smoothed), 1, 'first');

        % Remove the leading continuous NaNs
        xx_smoothed = uncut_xx_smoothed(firstNonNaNIndex:end);
        tvec = uncut_tvec(firstNonNaNIndex:end);
    else
        xx_smoothed = uncut_xx_smoothed;
        tvec = (-30*60 + 6):3:10*60;
        tvec = tvec / 60;
    end 

    saveDirParticipant = [saveDirAdjustedBifurcation, uniqueTable.Patient_ID{row_idx}, '/Night_' uniqueTable.Nights_for_Modelling(row_idx), '/' ]; 
    if ~exist(saveDirParticipant, 'dir')
       mkdir(saveDirParticipant);
    end

    % Plot the Orig Bifurcation
    %bif = uniqueTable.Fitted_Bifurcation_Model{row_idx};
    %c = uniqueTable.Control_Parameter{row_idx};
    %c = c(1:length(c) - 9);

    %dd_orig = [bif,c]; 

    %init_params = uniqueTable.Optimal_Params{row_idx};
    %if isnan(uncut_xx_smoothed(1))
    %    plot_bifurcation_pipeline(dd_orig(firstNonNaNIndex:end, :), uncut_xx_smoothed(firstNonNaNIndex:end), uncut_tvec(firstNonNaNIndex:end), saveDirParticipant, uniqueTable.Patient_ID{row_idx}, init_params, 1, 0)
    %else
    %    plot_bifurcation_pipeline(dd_orig, uncut_xx_smoothed, uncut_tvec, saveDirParticipant, uniqueTable.Patient_ID{row_idx}, init_params, 1, 0)
    %end 

    %% Adjust the bifurcation
    [params_tuned_coarsely,rsq_init1,rsq_final1,dd1,xini,iffail1] = tunebif_param([], xx_smoothed, tvec);

    %% Further finetune it 

    [params_tuned,rsq_ini,mse_ini, rsq_final,mse_final,dd,iffail] = finetune_bif_rev(params_tuned_coarsely,xx_smoothed,tvec,xini, 1000);
    
    %[params_optim,rsq_ini,rsq_final,dd,iffail] = finetune_bif(params_tuned_coarsely, xx_smoothed, tvec, xini);
    
    %% IF it still failed 

    uniqueTable.UpdatedMSEScore(row_idx) = mse_final;

    %% Plot the adjusted bifurcation
    [criticalS, c3sol] = plot_bifurcation_pipeline(dd, xx_smoothed, tvec, saveDirParticipant, uniqueTable.Patient_ID{row_idx}, params_tuned, 0, 1);

    if isempty(criticalS)

        uniqueTable.Updated_Optimal_Params{row_idx} = params_tuned;
        uniqueTable.Updated_R_square(row_idx) = rsq_final;
        uniqueTable.UpdatedTimeVec{row_idx} = tvec;
        uniqueTable.Updated_Fitted_Bifurcation_Model{row_idx} = dd(:, 1);
        uniqueTable.Updated_Control_Parameter{row_idx} = dd(:,2);
        uniqueTable.Updated_SVariableCriticalZone(row_idx) = 0;
        uniqueTable.Updated_C_3_Solutions{row_idx} = c3sol;
       
        
        
        % Run transcritical detections
        sfitnow = uniqueTable.Updated_Fitted_Bifurcation_Model{row_idx};
        %sfitnow = sfitnow(21:end);
        diff_sfitnow = diff(sfitnow);
        min_deriv_idx = find(diff_sfitnow == min(diff_sfitnow));
        idx_critic = min_deriv_idx+1+20;
 
        % No Critical point at all
        if abs(min(diff_sfitnow))<0.005 || (idx_critic >= length(sfitnow))
            uniqueTable.ifSuccessfullyFitted(row_idx) = 0;
            disp(['Participant ', uniqueTable.Patient_ID{row_idx},' Night ',num2str(uniqueTable.Nigths_for_Modelling(row_idx)),' No Critical point detected at all'])
            uniqueTable.ifSuccessfullyFitted(row_idx) = 0;
            continue
        else
            uniqueTable.ifTranscritical(row_idx) = 1;    % Transcritical case
            t_critc = tvec(idx_critic);
            c = uniqueTable.Updated_Control_Parameter{row_idx};
            c_critc = c(idx_critic);
            criticalSValue = sfitnow(idx_critic);
            uniqueTable.Updated_SVariableCriticalZone(row_idx) = criticalSValue;
            uniqueTable.ifSuccessfullyFitted(row_idx) = 1;
            disp(['Participant ', uniqueTable.Patient_ID{row_idx},' Night ',num2str(uniqueTable.Nights_for_Modelling(row_idx))])
        end
    else
        criticalSValue = max(criticalS);
    end 

    
    mean_hypnogram = uniqueTable.Mean_Hypnogram{row_idx};

    [finalCrossingValues_model, realCrossingValues_model, realCrossingTimePoints_model, crossingValues_model, crossingTimePoints_model, crossingDetails_model, lastPositiveCrossing_model] = identify_crossing_points(xx_smoothed, criticalSValue, tvec, mean_hypnogram, saveDirParticipant, 1, 'Bifurcation', dd(:, 1));
    
    if ~isempty(realCrossingTimePoints_model)
        uniqueTable.ModelFalseAlarmRate(row_idx) = length(realCrossingTimePoints_model) - 1;
        uniqueTable.ModelCrossingTime(row_idx) = realCrossingTimePoints_model(end);
    else
        uniqueTable.ifModelFailedCrossingPoint(row_idx) = 1;
        uniqueTable.ModelFalseAlarmRate(row_idx) = 0;
        uniqueTable.ModelCrossingTime(row_idx) = 0;
    end 

    uniqueTable.ModelCrossingDetails{row_idx} = crossingDetails_model;

    estimatedSVariables = uniqueTable.Estimated_S_variables{row_idx};
    night_hypnograms = uniqueTable.Night_Hypnograms{row_idx};

    night_used = str2num(uniqueTable.Nights_for_Modelling(row_idx));

    %nights_left = setdiff(A, B);

    participantTimePoints = [];
    participantEarliestTimePoints = [];
    participantLatestTimePoints = [];
    participantMeanTimePoints = [];
    participantFalseAlarmRates = [];
    participantCrossingDetails = {};
    participantFinalCrossingValues = [];
    participantLastPositiveCrossing = [];

    allEarliestNREM2BeforeSleep = [];
    allLatestNREM2BeforeSleep = [];
    allNumberPreSleepNREM2 = [];
    allTotalNREM1Duration = [];
    allTotalDuration = [];
    allProportionNREM1 = [];
    allPreonsetSleepDepth = [];
    allInconsistencyIndex = [];
    allFluctuationIndexAll = [];
    allFluctuationIndex = [];
    allRelativeWakeDuration = [];
    allRelativeNREM1Duration = [];
    allEarliestWakeTransition = [];
    allPostOnsetSleepDepth = [];
    allFluctuationIndexPost = [];
    allStdValue = [];
    allSmoothness = [];
    allKurtosisValue = [];
    allRMSSD = [];
    allRMS = [];  

    cell_crossing_time_points = cell(1, length(estimatedSVariables));

    globalMin = uniqueTable.Global_Minimum{row_idx};
    failedPredictionMask = zeros(length(estimatedSVariables), 1);
    for n_n = 1:length(estimatedSVariables)

    
        distPerNight1 = estimatedSVariables{n_n};
        uncut_xx_smoothed = smoothdata(distPerNight1, 'movmedian', [smoothingWindow, 0], 'omitmissing');
        uncut_xx_smoothed  = uncut_xx_smoothed - globalMin;
        uncut_xx_smoothed = uncut_xx_smoothed(1:length(uncut_xx_smoothed) - 9);
        uncut_tvec =  (-30*60 + 6):3:10*60;
        uncut_tvec = uncut_tvec / 60;
        tvec_night = uncut_tvec(max(1, length(uncut_tvec) - length(uncut_xx_smoothed)+1): end); 
        xx_smoothed = uncut_xx_smoothed(max(1,  length(uncut_xx_smoothed) - length(tvec_night) +1): end);
        current_hypnogram = night_hypnograms{n_n};
        
        [finalCrossingValues, realCrossingValues, realCrossingTimePoints, crossingValues, crossingTimePoints, crossingDetails, lastPositiveCrossing] = identify_crossing_points(xx_smoothed, criticalSValue, tvec_night, current_hypnogram, saveDirParticipant, 0, 'NightNumber', n_n);


        falseAlarmRate = 0;
        if ~isempty(realCrossingTimePoints)
            falseAlarmRate = length(realCrossingTimePoints) - 1;
        else
            failedPredictionMask(n_n) = 1;
        end 

        

        earliestTimepointDetected = NaN;
        latestTimepointDetected = NaN;
        meanTimepoiuntDetected = NaN;

        if ~isempty(realCrossingTimePoints)
            earliestTimepointDetected = realCrossingTimePoints(1);
            if length(realCrossingTimePoints) >=2
                latestTimepointDetected = realCrossingTimePoints(length(realCrossingTimePoints));
            else
                latestTimepointDetected = realCrossingTimePoints;
            end
            meanTimepoiuntDetected = mean(realCrossingTimePoints, 'omitmissing');
        end
        
        cell_crossing_time_points{n_n} = realCrossingTimePoints;
        participantTimePoints = [participantTimePoints, realCrossingTimePoints];
        participantEarliestTimePoints = [participantEarliestTimePoints, earliestTimepointDetected];
        participantLatestTimePoints = [participantLatestTimePoints, latestTimepointDetected];
        participantMeanTimePoints = [participantMeanTimePoints, meanTimepoiuntDetected];
        participantFalseAlarmRates = [participantFalseAlarmRates, falseAlarmRate];
        participantCrossingDetails  = [participantCrossingDetails, crossingDetails];
        participantFinalCrossingValues = [participantFinalCrossingValues, finalCrossingValues];
        participantLastPositiveCrossing = [participantLastPositiveCrossing, lastPositiveCrossing];

        %% Calculate the sleep statistics 
        current_hypnogram = night_hypnograms{n_n};
        postSleepPeriod = current_hypnogram((length(current_hypnogram) - 20) : end);
        preSleepPeriod = current_hypnogram(1: length(current_hypnogram) - 21);
        sleepOnsetIndex = (length(current_hypnogram) - 20);

        % Initialization
        ifPreSleepNREM2 = false;
        numberPreSleepNREM2 = 0;
        earliestNREM2BeforeSleep = 0; % Initialize to NaN to handle cases with no NREM2
        latestNREM2BeforeSleep = 0; % Initialize to NaN to handle cases with no NREM2
        
        if sum(preSleepPeriod == 2) > 0
            ifPreSleepNREM2 = true;
            numberPreSleepNREM2 = sum(preSleepPeriod == 2);
        
            % Correct use of find to get indices of NREM2
            nrem2Indices = find(preSleepPeriod == 2);
            
            % Correct calculation of distances
            earliestNREM2Index = nrem2Indices(1); % First occurrence of NREM2
            latestNREM2Index = nrem2Indices(end); % Last occurrence of NREM2
            earliestNREM2BeforeSleep = epoch_dur * (sleepOnsetIndex - earliestNREM2Index);
            latestNREM2BeforeSleep = epoch_dur * (sleepOnsetIndex - latestNREM2Index);
        end
        
        % Ensure you handle NaN cases or no NREM2 cases gracefully when displaying results
        fprintf('Earliest Failed Sleep Attempt (NREM2): %g minutes\n', earliestNREM2BeforeSleep);
        fprintf('Latest Failed Sleep Attempt (NREM2): %g minutes\n', latestNREM2BeforeSleep);
        fprintf('Number of Failed Sleep Attempt (NREM2): %d\n', numberPreSleepNREM2);
    
    
        % Example input
        %preSleepPeriod = [0 0 0 1 1 1 0 1 0 0 1 1 0 0];
        
        % Find NREM1 bouts starts
        startNREM1 = find(diff([0 preSleepPeriod]) == 1);
        
        % Initialize endNREM1 array
        endNREM1 = zeros(size(startNREM1));
        
        % For each NREM1 start, find the next change in sleep stage
        for ind = 1:length(startNREM1)
            nextChangeIndex = find(preSleepPeriod(startNREM1(ind):end) ~= 1, 1, 'first');
            if isempty(nextChangeIndex)
                % If no change is found, the end is the last index of preSleepPeriod
                endNREM1(ind) = length(preSleepPeriod);
            else
                % Adjust for the actual position
                endNREM1(ind) = startNREM1(ind) + nextChangeIndex - 2;
            end
        end
        
        % Calculate duration of each NREM1 bout and total NREM1 duration
        NREM1Durations = (endNREM1 - startNREM1 + 1) * 0.5; % Duration in minutes (each index is 30 seconds)
        totalNREM1Duration = sum(NREM1Durations); % Total duration in NREM1
    
        % Calculate total duration of preSleepPeriod
        totalDuration = length(preSleepPeriod) * 0.5; % Total duration in minutes
        
        % Calculate the proportion of time spent in NREM1
        proportionNREM1 = totalNREM1Duration / totalDuration;
        
        % Calculate inconsistency metric (simple version)
        % Count of transitions can indicate inconsistency
        numTransitions = sum(abs(diff(preSleepPeriod)) > 0); % Counting transitions
        numTransitionsAll = sum(abs(diff(current_hypnogram)) > 0); % Counting transitions
        inconsistencyIndex = numTransitions / totalNREM1Duration; % Adjusted by total NREM1 duration
        
        % Fluctuation Index
        % Simple measure based on the total number of state changes
        fluctuationIndex = numTransitions / totalDuration; % Adjusted by total duration
        fluctuationIndexAll = numTransitionsAll / length(current_hypnogram) * 0.5 ; %
        
        % Compute sleep depth pre-onset
        preonsetSleepDepth = mean(preSleepPeriod);
        
        % Output the results
        fprintf('NREM1 Durations (minutes): '); fprintf('%g ', NREM1Durations); fprintf('\n');
        fprintf('Total Duration in NREM1: %g minutes\n', totalNREM1Duration);
        fprintf('Total Pre-sleep Duration: %g minutes\n', totalDuration);
        fprintf('Proportion of Time in NREM1: %g\n', proportionNREM1);
        fprintf('Inconsistency Index: %g\n', inconsistencyIndex);
        fprintf('Fluctuation Index: %g\n', fluctuationIndex);
        fprintf('Pre-Sleep-Onset Sleep Depth: %g\n', preonsetSleepDepth);
    
    
        %% Calculate Post-Falling Asleep Stats
        % Example dummyvariable to test whether it works
        %postSleepPeriod = [2, 2, 3, 3, 2, 0, 2, 3, 0, 1, 0, 2, 5, 5, 0, 2, 2, 0, 3, 3];
    
        % Count wake (0) epochs in postSleepPeriod for relative duration calculations
        numWakeEpochs = sum(postSleepPeriod == 0);
        numNREM1Epochs = sum(postSleepPeriod == 1);
        
        % Total duration of wake epochs in minutes
        totalWakeDuration = numWakeEpochs * epoch_dur;
        totalNREM1DurationPost = numNREM1Epochs * epoch_dur;
        
        % Total duration of the postSleepPeriod
        totalPostDuration = length(postSleepPeriod) * epoch_dur;
        
        % Relative duration of wake epochs
        relativeWakeDuration = totalWakeDuration / totalPostDuration;
        relativeNREM1Duration = totalNREM1DurationPost / totalPostDuration;
        
        % Count of total transitions
        totalTransitions = sum(abs(diff(postSleepPeriod)) > 0);
        
        % Calculate the transitions to wake. A transition to wake is identified by a change from any non-zero state to 0.
        % Initialize a vector to hold the indices of transitions to wake
        wakeTransitions = find(diff(postSleepPeriod) == -postSleepPeriod(1:end-1) & postSleepPeriod(2:end) == 0);
        
        % Calculate the earliest transition to wake after sleep onset, if any
        if ~isempty(wakeTransitions)
            earliestWakeTransition = wakeTransitions(1) * epoch_dur;
        else
            earliestWakeTransition = NaN;
        end
    
        % Calculate the average sleep depth
        postOnsetSleepDepth = mean(postSleepPeriod); 
        
        % Calculate the fluctuation index for the postSleepPeriod
        fluctuationIndexPost = totalTransitions / totalPostDuration;
        
        % Output post-sleep stats for verification
        fprintf('Post-Sleep Wake Duration (minutes): %g\n', totalWakeDuration);
        fprintf('Post-Sleep NREM1 Duration (minutes): %g\n', totalNREM1DurationPost);
        fprintf('Relative Wake Duration: %g\n', relativeWakeDuration);
        fprintf('Relative NREM1 Duration: %g\n', relativeNREM1Duration);
        fprintf('Earliest Wake Transition (minutes): %g\n', earliestWakeTransition);
        fprintf('Average Sleep Depth: %g\n', postOnsetSleepDepth);
        fprintf('Fluctuation Index (Post-Sleep): %g\n', fluctuationIndexPost);
        
        %% Calculate the variability/peakiness within the S-variable 
        % Fill the missing values in S_variable 
        S_variable = fillmissing(xx_smoothed, "previous");
        S_variable = fillmissing(xx_smoothed, 'next');
    
        % Calculate STD
        stdValue = std(S_variable);
    
        % Calculate smoothness (average second derivative of a signal)
        first_derivative = diff(S_variable);
        second_derivative = diff(first_derivative);
        smoothness = mean(abs(second_derivative));
    
        % Calculate kurtosis 
        kurtosisValue = kurtosis(S_variable);
    
        % Calculate RMSSD
        differences = diff(S_variable); % calculate successive differences
        squredDifferences = differences.^2; 
        RMSSD = sqrt(mean(squredDifferences));

        rootmeansquare = rms(S_variable);
        
        fprintf('STD: %f\n', stdValue);
        fprintf('Smoothness metric: %f\n', smoothness);
        fprintf('Kurtosis: %f\n', kurtosisValue);
        fprintf('RMSSD: %f\n', RMSSD);
        fprintf('RMS: %f\n', rootmeansquare)
    
        
        allEarliestNREM2BeforeSleep = [allEarliestNREM2BeforeSleep, earliestNREM2BeforeSleep];
        allLatestNREM2BeforeSleep = [allLatestNREM2BeforeSleep, latestNREM2BeforeSleep];
        allNumberPreSleepNREM2 = [allNumberPreSleepNREM2, numberPreSleepNREM2];
        allTotalNREM1Duration = [allTotalNREM1Duration, totalNREM1Duration];
        allTotalDuration = [allTotalDuration, totalDuration];
        allProportionNREM1 = [allProportionNREM1, proportionNREM1];
        allPreonsetSleepDepth = [allPreonsetSleepDepth, preonsetSleepDepth];
        allInconsistencyIndex = [allInconsistencyIndex, inconsistencyIndex];
        allFluctuationIndexAll = [allFluctuationIndexAll, fluctuationIndexAll];
        allFluctuationIndex = [allFluctuationIndex,fluctuationIndex];
        allRelativeWakeDuration = [allRelativeWakeDuration,  relativeWakeDuration];
        allRelativeNREM1Duration = [allRelativeNREM1Duration, relativeNREM1Duration];
        allEarliestWakeTransition = [allEarliestWakeTransition, earliestWakeTransition];
        allPostOnsetSleepDepth = [allPostOnsetSleepDepth, postOnsetSleepDepth];
        allFluctuationIndexPost = [allFluctuationIndexPost, fluctuationIndexPost];
        allStdValue = [allStdValue, stdValue];
        allSmoothness = [allSmoothness, smoothness];
        allKurtosisValue = [allKurtosisValue , kurtosisValue];
        allRMSSD = [allRMSSD, RMSSD];
        allRMS = [allRMS, rootmeansquare];

    end 
    
    participantName = uniqueTable.Patient_ID{row_idx};

    plot_predictions_together(estimatedSVariables, criticalSValue, globalMin, saveDirParticipant)



    meanEarliestNREM2BeforeSleep = mean(allEarliestNREM2BeforeSleep, 'omitmissing');
    meanLatestNREM2BeforeSleep = mean(allLatestNREM2BeforeSleep, 'omitmissing');
    meanNumberPreSleepNREM2 = mean(allNumberPreSleepNREM2, 'omitmissing');
    meanTotalNREM1Duration = mean(allTotalNREM1Duration, 'omitmissing');
    meanTotalDuration = mean(allTotalDuration, 'omitmissing');
    meanProportionNREM1 = mean(allProportionNREM1, 'omitmissing');
    meanPreonsetSleepDepth = mean(allPreonsetSleepDepth, 'omitmissing');
    meanInconsistencyIndex = mean(allInconsistencyIndex, 'omitmissing');
    meanFluctuationIndexAll = mean(allFluctuationIndexAll, 'omitmissing');
    meanFluctuationIndex = mean(allFluctuationIndex, 'omitmissing');
    meanRelativeWakeDuration = mean(allRelativeWakeDuration, 'omitmissing');
    meanRelativeNREM1Duration = mean(allRelativeNREM1Duration, 'omitmissing');
    meanEarliestWakeTransition = mean(allEarliestWakeTransition, 'omitmissing');
    meanPostOnsetSleepDepth = mean(allPostOnsetSleepDepth, 'omitmissing');
    meanFluctuationIndexPost = mean(allFluctuationIndexPost, 'omitmissing');
    meanStdValue = mean(allStdValue, 'omitmissing');
    meanSmoothness = mean(allSmoothness, 'omitmissing');
    meanKurtosisValue = mean(allKurtosisValue, 'omitmissing');
    meanRMSSD = mean(allRMSSD, 'omitmissing');
    meanRMS = mean(allRMS, 'omitmissing');

    plot_timepoint_histograms(participantEarliestTimePoints, participantLatestTimePoints, participantMeanTimePoints,  participantTimePoints, saveDirParticipant)

    
    meanParticipantEarliestTimepoint = mean(participantEarliestTimePoints, 'omitmissing');
    stdParticipantEarliestTimepoint = std(participantEarliestTimePoints, 'omitmissing');
    meanParticipantLatestTimepoint = mean(participantLatestTimePoints, 'omitmissing');
    stdParticipantLatestTimepoint = std(participantLatestTimePoints, 'omitmissing');
    meanParticipantMeanTimepoint = mean(participantMeanTimePoints, 'omitmissing');
    stdParticipantMeanTimepoint = std(participantMeanTimePoints, 'omitmissing');
    meanParticipantAllTimepoint = mean(participantTimePoints, 'omitmissing');
    stdParticipantAllTimepoint = std(participantTimePoints, 'omitmissing');
    meanFalseAlarmRate = mean(participantFalseAlarmRates, 'omitmissing');
    stdFalseAlarmRate = std(participantFalseAlarmRates, 'omitmissing');

    earliestTimePoints = [earliestTimePoints, participantEarliestTimePoints];
    latestTimePoints = [latestTimePoints, participantLatestTimePoints];
    meanTimePoints = [meanTimePoints, participantMeanTimePoints];
    allTimePoints = [allTimePoints, participantTimePoints];
    allFalseAlarmRates = [allFalseAlarmRates, participantFalseAlarmRates];


    %% Log everything into a table 
    
    uniqueTable.Updated_Optimal_Params{row_idx} = params_tuned;
    uniqueTable.Updated_R_square(row_idx) = rsq_final;
    uniqueTable.UpdatedTimeVec{row_idx} = tvec;
    uniqueTable.Updated_Fitted_Bifurcation_Model{row_idx} = dd(:, 1);
    uniqueTable.Updated_Control_Parameter{row_idx} = dd(:,2);
    uniqueTable.Updated_SVariableCriticalZone(row_idx) = criticalSValue;
    uniqueTable.Updated_C_3_Solutions{row_idx} = c3sol;

    uniqueTable.Predicted_Critical_TimePoints{row_idx} = cell_crossing_time_points;
    uniqueTable.CrossingDetailsCell{row_idx} = participantCrossingDetails;
    uniqueTable.AllFalseAlarmRates{row_idx} = participantFalseAlarmRates;
    uniqueTable.FinalCrossingValues{row_idx} = participantFinalCrossingValues;
    uniqueTable.LastPositiveCrossing{row_idx} = participantLastPositiveCrossing;
    uniqueTable.MeanFalseAlarmRate(row_idx) = meanFalseAlarmRate;
    uniqueTable.STDFalseAlarmRate(row_idx) = stdFalseAlarmRate;
    uniqueTable.Mean_Predicted_Critical_TimePoints(row_idx) = meanParticipantAllTimepoint;
    uniqueTable.STD_Predicted_Critical_TimePoints(row_idx) = stdParticipantAllTimepoint;
    uniqueTable.EarliestPredictedTimePointLatencies{row_idx} = participantEarliestTimePoints;
    uniqueTable.Mean_EarliestPredictedTimePointLatencies(row_idx) = meanParticipantEarliestTimepoint;
    uniqueTable.STD_EarliestPredictedTimePointLatencies(row_idx) = stdParticipantEarliestTimepoint;
    uniqueTable.AverageCriticalityLatency{row_idx} = participantMeanTimePoints;
    uniqueTable.Mean_AverageCriticalityLatency(row_idx) = meanParticipantMeanTimepoint;
    uniqueTable.STD_AverageCriticalityLatency(row_idx) = stdParticipantMeanTimepoint;
    uniqueTable.LatestPredictedTimePointLatencies{row_idx} = participantLatestTimePoints;
    uniqueTable.Mean_LatestPredictedTimePointLatencies(row_idx) = meanParticipantLatestTimepoint;
    uniqueTable.STD_LatestPredictedTimePointLatencies(row_idx) = stdParticipantLatestTimepoint;
    
    uniqueTable.EarliestNREM2PreSleep{row_idx} =  allEarliestNREM2BeforeSleep;
    uniqueTable.LatestNREM2PreSleep{row_idx} = allLatestNREM2BeforeSleep;
    uniqueTable.NumberNREM2PreSleep{row_idx} = allNumberPreSleepNREM2;
    uniqueTable.TotalNREM1DurationPreSleep{row_idx} = allTotalNREM1Duration;
    uniqueTable.TotalDurationPreSleep{row_idx} = allTotalDuration;
    uniqueTable.ProportionNREM1PreSleep{row_idx} = allProportionNREM1;
    uniqueTable.AverageSleepDepthPreSleep{row_idx} = allPreonsetSleepDepth;
    uniqueTable.InconsistencyIndex{row_idx} = allInconsistencyIndex;
    uniqueTable.FluctuationIndex{row_idx} = allFluctuationIndexAll;
    uniqueTable.FluctuationIndexPreSleep{row_idx} = allFluctuationIndex;
    uniqueTable.RelativeWakeDurationPostSleep{row_idx} = allRelativeWakeDuration;
    uniqueTable.RelativeNREM1DurationPostSleep{row_idx} = allRelativeNREM1Duration;
    uniqueTable.EarliestWakeTransitionPostSleep{row_idx} = allEarliestWakeTransition;
    uniqueTable.AverageSleepDepthPostSleep{row_idx} = allPostOnsetSleepDepth;
    uniqueTable.FluctuationIndexPostSleep{row_idx} = allFluctuationIndexPost;
    uniqueTable.STD_S{row_idx} = allStdValue;
    uniqueTable.Smoothness_S{row_idx} = allSmoothness;
    uniqueTable.Kurtosis_S{row_idx} = allKurtosisValue;
    uniqueTable.RMSSD_S{row_idx} = allRMSSD;
    uniqueTable.RMS_S{row_idx} = allRMS;

    uniqueTable.FailedPredictionsMask{row_idx} = failedPredictionMask;
    uniqueTable.ifOneFailure(row_idx) = any(logical(failedPredictionMask));
    uniqueTable.proportionFailure(row_idx) = sum(failedPredictionMask)/length(failedPredictionMask);


    uniqueTable.MeanEarliestNREM2PreSleep(row_idx) = meanEarliestNREM2BeforeSleep;
    uniqueTable.MeanLatestNREM2PreSleep(row_idx) = meanLatestNREM2BeforeSleep;
    uniqueTable.MeanNumberNREM2PreSleep(row_idx) =  meanNumberPreSleepNREM2;
    uniqueTable.MeanTotalNREM1DurationPreSleep(row_idx) = meanTotalNREM1Duration;
    uniqueTable.MeanTotalDurationPreSleep(row_idx) = meanTotalDuration;
    uniqueTable.MeanProportionNREM1PreSleep(row_idx) = meanProportionNREM1;
    uniqueTable.MeanAverageSleepDepthPreSleep(row_idx) = meanPreonsetSleepDepth;
    uniqueTable.MeanInconsistencyIndex(row_idx) = meanInconsistencyIndex;
    uniqueTable.MeanFluctuationIndex(row_idx) = meanFluctuationIndexAll;
    uniqueTable.MeanFluctuationIndexPreSleep(row_idx) = meanFluctuationIndex;
    uniqueTable.MeanRelativeWakeDurationPostSleep(row_idx) = meanRelativeWakeDuration;
    uniqueTable.MeanRelativeNREM1DurationPostSleep(row_idx) = meanRelativeNREM1Duration;
    uniqueTable.MeanEarliestWakeTransitionPostSleep(row_idx) = meanEarliestWakeTransition;
    uniqueTable.MeanAverageSleepDepthPostSleep(row_idx) = meanPostOnsetSleepDepth;
    uniqueTable.MeanFluctuationIndexPostSleep(row_idx) = meanFluctuationIndexPost;
    uniqueTable.MeanSTD_S(row_idx) = meanStdValue;
    uniqueTable.MeanSmoothness_S(row_idx) = meanSmoothness;
    uniqueTable.MeanKurtosis_S(row_idx) = meanKurtosisValue;
    uniqueTable.MeanRMSSD_S(row_idx) = meanRMSSD;
    uniqueTable.MeanRMS(row_idx) = meanRMS;
    else
        uniqueTable.ifSuccessfullyFitted(row_idx) = 1;
    end
end 

% Construct the filename for saving
matFilename = fullfile(saveDirAdjustedBifurcation, 'MissingFilledFinalReviewUniqueTable.mat');

% Save the uniqueTable as a .mat file
save(matFilename, 'uniqueTable');

earliestTimePoints = [];
latestTimePoints = [];
meanTimePoints = [];
allTimePoints = [];

for i = 1:length(uniqueTable.AllFalseAlarmRates)
    
        earliestTimePoints = [earliestTimePoints; uniqueTable.EarliestPredictedTimePointLatencies{i}(:)];
        latestTimePoints = [latestTimePoints; uniqueTable.LatestPredictedTimePointLatencies{i}(:)];
        meanTimePoints = [meanTimePoints; uniqueTable.AverageCriticalityLatency{i}(:)];
       
end

meanEarliestTimepoint = mean(earliestTimePoints, 'omitnan');
stdEarliestTimepoint = std(earliestTimePoints, 'omitnan');
meanLatestTimepoint = mean(latestTimePoints, 'omitnan');
stdLatestTimepoint = std(latestTimePoints, 'omitnan');
meanMeanTimepoint = mean(meanTimePoints, 'omitnan');
stdMeanTimepoint = std(meanTimePoints, 'omitnan');
meanAllTimepoint = mean(allTimePoints, 'omitnan');
stdAllTimepoint = std(allTimePoints, 'omitnan');

% Print out the results using disp()
disp(['Mean of Earliest Time Points: ', num2str(meanEarliestTimepoint)]);
disp(['Standard Deviation of Earliest Time Points: ', num2str(stdEarliestTimepoint)]);
disp(['Mean of Latest Time Points: ', num2str(meanLatestTimepoint)]);
disp(['Standard Deviation of Latest Time Points: ', num2str(stdLatestTimepoint)]);
disp(['Mean of Mean Time Points: ', num2str(meanMeanTimepoint)]);
disp(['Standard Deviation of Mean Time Points: ', num2str(stdMeanTimepoint)]);
disp(['Mean of All Time Points: ', num2str(meanAllTimepoint)]);
disp(['Standard Deviation of All Time Points: ', num2str(stdAllTimepoint)]);


%% Histogram of the earliest time points 
handle = figure;
histogram(earliestTimePoints, 'BinWidth', 1); % You can adjust the BinWidth or other properties as needed

% Add a vertical line for the mean
hold on;
xline(meanEarliestTimepoint, 'r--', 'LineWidth', 2) %, 'Label', sprintf('Mean = %.2f', meanEarliestTimepoint), 'LabelOrientation', 'horizontal', 'LabelVerticalAlignment', 'middle');
hold off;

% Add labels and title
set(gca,'FontSize', 16)
set(gca,'TickDir','out')
set(gca,'ticklength',2*get(gca,'ticklength'))
set(gca,'lineWidth',2)
set(gca, 'Box', 'off')
set(gca, 'FontName', 'Helvetica')
xlabel('Time Points');
ylabel('Frequency');
title(sprintf('Histogram of Earliest Time Points for Critical Transition\nMean = %.2f, Std = %.2f', meanEarliestTimepoint, stdEarliestTimepoint));
grid off;

% Construct filenames for saving
jpegFilename = fullfile(saveDirAdjustedBifurcation, 'EarliestTransitionDetection.jpg');
figFilename = fullfile(saveDirAdjustedBifurcation, 'EarliestTransitionDetection.fig');
svgFilename = fullfile(saveDirAdjustedBifurcation, 'EarliestTransitionDetection.svg');

% Save the plot as JPEG
saveas(handle, jpegFilename);

% Save the figure as .fig file
savefig(handle, figFilename);

% Save the plot as SVG
saveas(handle, svgFilename);


close(handle); % Close the figure

%% Histogram of the latest time points 
handle = figure;
histogram(latestTimePoints, 'BinWidth', 1); % You can adjust the BinWidth or other properties as needed

% Add a vertical line for the mean
hold on;
xline(meanLatestTimepoint, 'r--', 'LineWidth', 2) %, 'Label', sprintf('Mean = %.2f', meanLatestTimepoint), 'LabelOrientation', 'horizontal', 'LabelVerticalAlignment', 'middle');
hold off;

% Add labels and title
set(gca,'FontSize', 16)
set(gca,'TickDir','out')
set(gca,'ticklength',2*get(gca,'ticklength'))
set(gca,'lineWidth',2)
set(gca, 'Box', 'off')
set(gca, 'FontName', 'Helvetica')
xlabel('Time Points');
ylabel('Frequency');
title(sprintf('Histogram of Latest Time Points for Critical Transition\nMean = %.2f, Std = %.2f', meanLatestTimepoint, stdLatestTimepoint));
grid off;

% Construct filenames for saving
jpegFilename = fullfile(saveDirAdjustedBifurcation, 'LatestTransitionDetection.jpg');
figFilename = fullfile(saveDirAdjustedBifurcation, 'LatestTransitionDetection.fig');
svgFilename = fullfile(saveDirAdjustedBifurcation, 'LatestTransitionDetection.svg');

% Save the plot as JPEG
saveas(handle, jpegFilename);

% Save the figure as .fig file
savefig(handle, figFilename);

% Save the plot as SVG
saveas(handle, svgFilename);

close(handle); % Close the figure

%% Histogram of the mean of detection timepoints
handle = figure;
histogram(meanTimePoints, 'BinWidth', 1); % You can adjust the BinWidth or other properties as needed

% Add a vertical line for the mean
hold on;
xline(meanMeanTimepoint, 'r--', 'LineWidth', 2) %, 'Label', sprintf('Mean = %.2f', meanMeanTimepoint), 'LabelOrientation', 'horizontal', 'LabelVerticalAlignment', 'middle');
hold off;

% Add labels and title
set(gca,'FontSize', 16)
set(gca,'TickDir','out')
set(gca,'ticklength',2*get(gca,'ticklength'))
set(gca,'lineWidth',2)
set(gca, 'Box', 'off')
set(gca, 'FontName', 'Helvetica')
xlabel('Time Points');
ylabel('Frequency');
title(sprintf('Histogram of Mean Time Points for Critical Transition\nMean = %.2f, Std = %.2f', meanMeanTimepoint, stdMeanTimepoint));
grid off;

% Construct filenames for saving
jpegFilename = fullfile(saveDirAdjustedBifurcation, 'MeanTransitionDetection.jpg');
figFilename = fullfile(saveDirAdjustedBifurcation, 'MeanTransitionDetection.fig');
svgFilename = fullfile(saveDirAdjustedBifurcation, 'MeanTransitionDetection.svg');

% Save the plot as JPEG
saveas(handle, jpegFilename);

% Save the figure as .fig file
savefig(handle, figFilename);

% Save the plot as SVG
saveas(handle, svgFilename);

close(handle); % Close the figure

%% Histogram of all of the timepoints detected 
handle = figure;
histogram(allTimePoints, 'BinWidth', 1); % You can adjust the BinWidth or other properties as needed

% Add a vertical line for the mean
hold on; 
xline(meanAllTimepoint, 'r--', 'LineWidth', 2) %, 'Label', sprintf('Mean = %.2f', meanAllTimepoint), 'LabelOrientation', 'horizontal', 'LabelVerticalAlignment', 'middle');
hold off;

% Add labels and title
set(gca,'FontSize', 16)
set(gca,'TickDir','out')
set(gca,'ticklength',2*get(gca,'ticklength'))
set(gca,'lineWidth',2)
set(gca, 'Box', 'off')
set(gca, 'FontName', 'Helvetica')
xlabel('Time Points');
ylabel('Frequency');
title(sprintf('Histogram of All Time Points for Critical Transition\nMean = %.2f, Std = %.2f', meanAllTimepoint, stdAllTimepoint));
grid off;

% Construct filenames for saving
jpegFilename = fullfile(saveDirAdjustedBifurcation, 'AllTransitionDetection.jpg');
figFilename = fullfile(saveDirAdjustedBifurcation, 'AllTransitionDetection.fig');
svgFilename = fullfile(saveDirAdjustedBifurcation, 'AllTransitionDetection.svg');

% Save the plot as JPEG
saveas(handle, jpegFilename);

% Save the figure as .fig file
savefig(handle, figFilename);

% Save the plot as SVG
saveas(handle, svgFilename);


close(handle); % Close the figure